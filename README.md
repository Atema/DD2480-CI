# DD2480 Group 7: CI Server

This program is a Continuous Integration (CI) Server that is able to build itself after being triggered by GitHub. It will run the included tests and the build process, save the build into a database, and report the success or failure of the build back to GitHub.

## Build requirements

A recent version of the Java JDK (at least 11) is necessary for building and testing the project. Ensure that environment variables are set correctly for automatic detection of the JDK.

## Build instructions

*Note that for successfull completion of the build, setting the CI_TOKEN environment variable is necessary (see section below).*

Building the project is automated using Gradle. From the root directory of the project, running `./gradlew build` (on Linux or Mac OS X) or `.\gradlew.bat build` (on Windows) will compile the code in `src/main`. The resulting executable `jar` will be stored in the directory `build/libs`.

## Test instructions

*Note that for successfull completion of the tests, setting the CI_TOKEN environment variable is necessary (see section below).*

All tests in `src/test` will be executed as part of the build process in the previous section. To rerun all tests, `./gradlew test --rerun-tasks` (on Linux or Mac OS X) or `.\gradlew.bat test --rerun-tasks` (on Windows) can be ran from the root directory of the project. Test results are in both cases printed to the terminal. At the same time, a browsable report of the results is generated in the directory `reports/tests/test`.

## Documentation

Documentation in the code was added as JavaDoc comments. As part of the build process, a browsable (HTML) version of the documentation will be generated in the directory `build/docs/javadoc`.

## Execution instructions

*Note that for successfull execution of all program features, setting the CI_TOKEN environment variable is necessary (see section below).*

The CI Server can be executed directly from the project root by executing `./gradlew run` (on Linux or Mac OS X) or `.\gradlew.bat run` (on Windows); this command will build the program if necessary. Alternatively, the `jar` generated by the build process is a standalone version of the server.

## Features

Our CI Server exposes an HTTP server on port `8080`. Some kind of port forwarding is essential to make this port publicly available.

### Receiving GitHub webhooks

Our CI server is able to receive webhook requests from GitHub on the path `/request` (using `POST`). After receival of a request, the build process will be started.

#### Implementation and testing

This feature is implemented in the class `BuildRequestServlet` using a Jetty servlet. Unit testing is contained in the class `BuildRequestServletTests`, where a fake request of correct format is done to ensure the request format is parsed correctly.

### Cloning a repository

Our CI server will automatically clone the concerning repository in a temporary folder, and check out the correct commit.

#### Implementation and testing

This feature is implemented in the method `cloneRepo` of the class `Build` using JGit. Unit testing is contained in the class `BuildTests`, where a specific commit in our own repository is cloned to test the correct working of the function.

### Building and running tests

After cloning the repository, our CI server will automatically build the program contained in the folder using the included `gradlew` Gradle wrapper. Since this both builds the code and execute tests (where the build will only complete when all tests have passed), these functionalities are combined.

#### Implementation and testing

This feature is implemented in the method `build` of the class `Build`, which spawns a process that runs the Gradle build. Unit testing is contained in the class `BuildTests`, where two different revisions of our repository (one known succeeding build and one known failing build) are built to test the correctness of the method.

### Reporting GitHub status

After building has finished, our CI server will report its status to GitHub as `success` (passing build), `failure` (failing build), or `error` (exception occured while trying to build), which will be visible with the commit.

#### Implementation and testing

This feature is implemented in the method `reportGitHubStatus` of the class `BuildResult`, which sends a `POST` request to the GitHub API. In the class `BuildResultTests`, the response from the API is checked to ensure the correctness of the method.

### Viewing build history

Besides reporting the status to GitHub, our CI server will store detailed information about the build in a database, and allows the user to browse these by opening the path `/` on the server in a web browser. Besides the status, information about the respective commit and the complete build log for each build can be viewed.

#### Implementation and testing

The database for storing all past builds is implemented using a SQLite database in the class `BuildDatabase`. Tests included in the class `BuildDatabaseTests` are used to ensure that it is possible to insert, retrieve and delete items from the database correctly. A template (implemented using Apache FreeMarker, with styling using Bootstrap) is combined with the data from the database in the class `BuildHistoryServlet`, which will serve the necessary files for showing the interface to the browser.

## Setting the CI_TOKEN environment variable

For authentication with GitHub, a personal access token with `repo` scope is required. See <https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token> for information about generating this token.

The generated token needs to be exposed as the environment variable `CI_TOKEN`. The command to do this is dependent on the operating system. On Windows, `set CI_TOKEN=azbycx` (in Command Line) or `$Env:CI_TOKEN="azbycx"` (in PowerShell) can be used to set it for the current shell session. On Linux or Mac OS X, `export CI_TOKEN=azbycx` can be used to set it for the current shell session, or `CI_TOKEN=azbycx` can be prepended to a command to set it for a single command.

## Contributions

In general, everyone was helpfull in all areas of the project. Continuous dialog was held through meetings and discord. Major contributions of all members are mentioned below.

**Martijn Atema** (atema@kth.se)

- Decided the structure of the software and setting up Gradle
- Implemented the build history database and web interface

**Pierre Colson** (coslon@kth.se)

- Implemented functionality to clone a repository and its tests

**Hugo Heyman** (hheyman@kth.se)

- Implemented functionality to submit GitHub status and receive the response through GitHub API.

**Hafsa Aoutir** (hafsaa@kth.se)

- Implemented functionality to run a build and its tests

**Linnea Bonnevier** (lmebo@kth.se)

- Implemented functionality to receive a request and its tests
